console.log('jira-to-mcp: script load');
process.on('uncaughtException', (err) => console.error('uncaughtException:', err));
process.on('unhandledRejection', (reason) => console.error('unhandledRejection:', reason));

import { promises as fs } from "fs";
const fetch = require('node-fetch');

const logger = {
    info: (data: any, msg?: string) => console.log(msg ?? "", data),
    error: (err: any, msg?: string) => console.error(msg ?? "", err)
};

function getEnv(name: string): string {
    const value = process.env[name];
    if (!value) throw new Error(`Missing environment variable: ${name}`);
    return value.replace(/^"|"$/g, "");
}

const JIRA_BASE = getEnv("JIRA_BASE");
const JIRA_EMAIL = getEnv("JIRA_EMAIL");
const JIRA_TOKEN = getEnv("JIRA_TOKEN");
const JIRA_PROJECT = getEnv("JIRA_PROJECT");
const MCP_ENDPOINT = getEnv("MCP_ENDPOINT");

function maskSecret(s: string) {
    if (!s) return "";
    if (s.length <= 8) return "****";
    return `${s.slice(0, 4)}****${s.slice(-4)}`;
}

// --- Pull requirements by label ---
// Commented out live JIRA fetch for now
/*
async function listRequirements(label: string) {
  const jql = `project=${JIRA_PROJECT} AND labels=${label} AND statusCategory!=Done`;
  const url = `${JIRA_BASE}/rest/api/3/search/jql?jql=${encodeURIComponent(jql)}&startAt=0&maxResults=100`;

  const basic = Buffer.from(`${JIRA_EMAIL}:${JIRA_TOKEN}`).toString("base64");

  const res = await fetch(url, {
    method: "GET",
    headers: {
      "Authorization": `Basic ${basic}`,
      "Accept": "application/json"
    }
  });

  logger.info({ status: res.status, url }, "JIRA response");
  if (!res.ok) {
    const body = await res.text().catch(() => "<no body>");
    logger.error({ url, status: res.status, body }, "JIRA API error");
    throw new Error(`JIRA API error ${res.status}: ${body}`);
  }

  const data: any = await res.json();
  return (data.issues ?? []) as any[];
}
*/

// --- Mocked JIRA response ---
async function listRequirements(label: string) {
    logger.info({ label }, "Mocking JIRA fetch");
    return [
        {
            key: "CPG-217",
            fields: {
                summary: "Get Customer Info API returns expected profile fields",
                description: `Endpoint: GET /api/customers/{customerId}
Returns: customerName, customerId, totalSavings, rewardsRedeemed
Validation: Error handling 404/400, non-negative amounts, performance P95≤300ms`,
                labels: [label],
                customfield_acceptance_criteria: [
                    "AC1: 200 OK for valid IDs",
                    "AC2: Fields present and well-typed",
                    "AC3: 404 for unknown ID",
                    "AC4: 400 for invalid ID format",
                    "AC5: Non-negative amounts",
                    "AC6: P95 ≤ 300ms"
                ]
            }
        }
    ];
}

function toGherkin(issue: any): string {
    const title = issue.fields?.summary ?? "(no title)";
    const ac = (issue.fields?.description || "").trim();
    return `Feature: ${title}\n\nScenario: Default\n${ac}`;
}

async function mcpGenerate(gherkin: string, env: string): Promise<string> {
    logger.info({ env, length: gherkin.length }, "Sending request to MCP /generate");
    const res = await fetch(`${MCP_ENDPOINT}/generate`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
            instructions: `Generate Rest Assured (Java, JUnit5) tests + test data for ${env}. Cover valid/404/400, schema, non-negative amounts, performance.`,
            input: gherkin
        })
    });

    logger.info({ status: res.status }, "MCP response status");
    if (!res.ok) {
        const body = await res.text().catch(() => "<no body>");
        logger.error({ status: res.status, body }, "MCP error response");
        throw new Error(`MCP error: ${res.status}`);
    }

    const data = (await res.json()) as { code?: string };
    if (!data.code) {
        logger.error(data, "MCP response missing code");
        throw new Error("MCP response missing 'code' field");
    }

    logger.info({ codeLength: data.code.length }, "MCP returned code");
    return data.code;
}

async function run() {
    logger.info(
        { JIRA_BASE, JIRA_PROJECT, MCP_ENDPOINT, JIRA_EMAIL, JIRA_TOKEN: maskSecret(JIRA_TOKEN) },
        "Starting jira-to-mcp"
    );

    const issues = await listRequirements("Testing");
    logger.info({ count: issues.length }, "Fetched issues");

    for (const issue of issues) {
        const key = issue.key ?? "(unknown)";
        const title = issue.fields?.summary ?? "(no title)";
        logger.info({ key, title }, "Processing issue");

        try {
            const gherkin = toGherkin(issue);
            const env = "TEST";
            const code = await mcpGenerate(gherkin, env);

            const dir = `tests/src/test/java/com/bank/api`;
            const outPath = `${dir}/${key.replace(/[^A-Za-z0-9]/g, "_")}_CustomerInfoTests.java`;

            await fs.mkdir(dir, { recursive: true });
            await fs.writeFile(outPath, code, "utf8");
            logger.info({ key, env, outPath }, "Test generated");
        } catch (err) {
            logger.error(err, `Failed to process issue ${key}`);
        }
    }

    logger.info({}, "Run complete");
}

run().catch((err) => {
    logger.error(err, "Unhandled error in run");
    process.exit(1);
});
